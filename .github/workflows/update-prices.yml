name: Update Prices

on:
  workflow_dispatch:
  schedule:
    - cron: "*/15 * * * *"

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Create app.py (Sheet-driven, robust SKU matching, distributor formula, rounding)
        run: |
          cat > app.py << 'PY'
          import os
          import csv
          import io
          import time
          from decimal import Decimal, getcontext, InvalidOperation
          import requests
          import gspread

          getcontext().prec = 28

          PROVIDER_URL_DEFAULT = "https://store.dreamlove.es/dyndata/exportaciones/csvzip/catalog_1_50_125_2_eb10a792c0336bc695e2b0ec29d88402_csv_plain.csv?tkn=28cc4e818950d81c1d322225464f29e4a8fd9381c561188ba29ff5699cc273fd"

          ROUNDING_MULTIPLE = int(os.getenv("ROUNDING_MULTIPLE", "5"))
          ROUNDING_STRATEGY = os.getenv("ROUNDING_STRATEGY", "ceil").strip().lower()
          ROUNDING_AVOID_HUNDREDS = os.getenv("ROUNDING_AVOID_HUNDREDS", "true").strip().lower() in ("true", "1", "yes")
          if ROUNDING_MULTIPLE <= 0:
              ROUNDING_MULTIPLE = 5

          SHOPIFY_THROTTLE_SECONDS = int(os.getenv("SHOPIFY_THROTTLE_SECONDS", "3"))
          if SHOPIFY_THROTTLE_SECONDS < 0:
              SHOPIFY_THROTTLE_SECONDS = 0

          SKU_PREFIX_TO_STRIP = os.getenv("SKU_PREFIX_TO_STRIP", "").strip()

          def normalize_store(store):
              s = (store or "").strip()
              s = s.replace("https://", "").replace("http://", "")
              return s.strip("/")

          def parse_decimal(s):
              if s is None:
                  return None
              t = str(s).strip()
              if not t:
                  return None
              t = t.replace(" ", "")
              if "," in t and "." not in t:
                  t = t.replace(",", ".")
              try:
                  return Decimal(t)
              except Exception:
                  return None

          # price = precio_distribuidores * 1.262 * 1.35 = precio_distribuidores * 1.7037
          def compute_price_from_distributor(dist):
              raw = Decimal(dist) * Decimal("1.7037")
              m = Decimal(ROUNDING_MULTIPLE)
              if raw % m == 0:
                  price_int = int(raw)
              else:
                  price_int = int(((raw // m) + 1) * m)
              if ROUNDING_AVOID_HUNDREDS and price_int % 100 == 0:
                  price_int += ROUNDING_MULTIPLE
              return Decimal(price_int)

          def detect_delimiter(sample):
              first_line = sample.splitlines()[0] if sample else ""
              sc = first_line.count(";")
              cc = first_line.count(",")
              if sc > cc:
                  return ";"
              return ","

          def load_provider_map(url, ref_col, dist_col):
              r = requests.get(url, timeout=120)
              r.raise_for_status()
              text = r.content.decode("utf-8", errors="ignore")
              delim = detect_delimiter(text[:1000])
              reader = csv.DictReader(io.StringIO(text), delimiter=delim)
              m = {}
              for row in reader:
                  ref = row.get(ref_col)
                  dist = parse_decimal(row.get(dist_col))
                  if not ref or dist is None:
                      continue
                  m[str(ref).strip()] = dist
              return m

          def open_worksheet(creds_json, sheet_id, sheet_name):
              import json
              data = json.loads(creds_json)
              gc = gspread.service_account_from_dict(data)
              sh = gc.open_by_key(sheet_id)
              if sheet_name:
                  return sh.worksheet(sheet_name)
              return sh.get_worksheet(0)

          def find_column_index(header, name):
              name_l = name.strip().lower()
              for i, h in enumerate(header, start=1):
                  if str(h).strip().lower() == name_l:
                      return i
              return None

          def money_amount(m):
              if m is None:
                  return None
              if isinstance(m, dict):
                  a = m.get("amount")
                  if a is None:
                      return None
                  return str(a)
              return str(m)

          def to_decimal_safe(v):
              try:
                  return Decimal(str(v))
              except (InvalidOperation, TypeError):
                  return None

          def shopify_graphql(store, token, version, query, variables):
              url = f"https://{store}/admin/api/{version}/graphql.json"
              headers = {"X-Shopify-Access-Token": token, "Content-Type": "application/json"}
              time.sleep(SHOPIFY_THROTTLE_SECONDS)
              r = requests.post(url, json={"query": query, "variables": variables}, headers=headers, timeout=60)
              r.raise_for_status()
              return r.json()

          # Robust: productVariants search then filter exact match (case-insensitive), with multiple query shapes
          def shopify_variant_by_sku(store, token, version, sku):
              sku_norm = str(sku).strip()
              candidates = [sku_norm]
              if SKU_PREFIX_TO_STRIP and sku_norm.startswith(SKU_PREFIX_TO_STRIP):
                  candidates.append(sku_norm[len(SKU_PREFIX_TO_STRIP):])
              no_dash = sku_norm.replace("-", "")
              if no_dash != sku_norm:
                  candidates.append(no_dash)
              tokens = sku_norm.split("-")
              if len(tokens) > 1:
                  candidates.append(tokens[-1])

              queries = []
              for c in candidates:
                  queries.append(f'sku:"{c}"')
                  queries.append(f"sku:{c}")

              q = """
              query($q: String!) {
                productVariants(first: 50, query: $q) {
                  edges {
                    node {
                      id
                      sku
                      price { amount }
                      compareAtPrice { amount }
                    }
                  }
                }
              }
              """
              for qry in queries:
                  data = shopify_graphql(store, token, version, q, {"q": qry})
                  edges = data.get("data", {}).get("productVariants", {}).get("edges", [])
                  if not edges:
                      continue
                  for e in edges:
                      node = e.get("node", {}) or {}
                      found_sku = str(node.get("sku", "")).strip()
                      # case-insensitive exact match against any candidate
                      if found_sku.lower() in [c.lower() for c in candidates]:
                          return {
                              "id": node.get("id"),
                              "price": money_amount(node.get("price")),
                              "compare_at_price": money_amount(node.get("compareAtPrice")),
                              "matched_query": qry,
                              "found_sku": found_sku
                          }
              return None

          def shopify_update_variant_price(store, token, version, variant_gid, price):
              m = """
              mutation productVariantUpdate($input: ProductVariantInput!) {
                productVariantUpdate(input: $input) {
                  productVariant { id }
                  userErrors { field message }
                }
              }
              """
              variables = {"input": {"id": variant_gid, "price": str(price)}}
              data = shopify_graphql(store, token, version, m, variables)
              errs = data.get("data", {}).get("productVariantUpdate", {}).get("userErrors", [])
              if errs:
                  messages = "; ".join([e.get("message", "error") for e in errs])
                  raise RuntimeError(messages)
              return True

          def update_prices_in_shopify(ws, provider_map, sku_col_name, store, token, version):
              rows = ws.get_all_values()
              if not rows:
                  return {"updated": 0, "skipped_compare": 0, "missing_dist": 0, "not_found": 0, "unchanged": 0, "samples": {}}
              header = rows[0]
              sku_idx = find_column_index(header, sku_col_name)
              if sku_idx is None:
                  return {"updated": 0, "skipped_compare": 0, "missing_dist": 0, "not_found": 0, "unchanged": 0, "samples": {}}
              updated = 0
              skipped_compare = 0
              missing_dist = 0
              not_found = 0
              unchanged = 0
              samples = {"missing_dist": [], "not_found": [], "skipped_compare": [], "unchanged": [], "updated": [], "matched": []}

              for i in range(1, len(rows)):
                  row = rows[i]
                  sku = row[sku_idx - 1] if sku_idx - 1 < len(row) else ""
                  sku_key = str(sku).strip()
                  dist = provider_map.get(sku_key)
                  if dist is None:
                      missing_dist += 1
                      if len(samples["missing_dist"]) < 10:
                          samples["missing_dist"].append(sku_key)
                      continue

                  new_price = compute_price_from_distributor(dist)
                  var = shopify_variant_by_sku(store, token, version, sku_key)
                  if not var:
                      not_found += 1
                      if len(samples["not_found"]) < 10:
                          samples["not_found"].append(sku_key)
                      continue

                  if len(samples["matched"]) < 10:
                      samples["matched"].append({"sku": sku_key, "found_sku": var.get("found_sku"), "query": var.get("matched_query")})

                  if var.get("compare_at_price") is not None and str(var.get("compare_at_price")).strip() != "":
                      skipped_compare += 1
                      if len(samples["skipped_compare"]) < 10:
                          samples["skipped_compare"].append(sku_key)
                      continue

                  current_dec = to_decimal_safe(var.get("price"))
                  if current_dec is not None and current_dec == new_price:
                      unchanged += 1
                      if len(samples["unchanged"]) < 10:
                          samples["unchanged"].append(sku_key)
                      continue

                  try:
                      shopify_update_variant_price(store, token, version, var["id"], new_price)
                      updated += 1
                      if len(samples["updated"]) < 10:
                          samples["updated"].append(sku_key)
                  except Exception:
                      continue

              return {
                  "updated": updated,
                  "skipped_compare": skipped_compare,
                  "missing_dist": missing_dist,
                  "not_found": not_found,
                  "unchanged": unchanged,
                  "samples": samples
              }

          def main():
              provider_url = os.getenv("PROVIDER_URL", PROVIDER_URL_DEFAULT)
              ref_col = os.getenv("PROVIDER_REFERENCE_COLUMN", "referencia")
              dist_col = os.getenv("PROVIDER_DISTRIBUTOR_PRICE_COLUMN", "precio_distribuidores")
              sku_col = os.getenv("SKU_COLUMN", "SKU")
              sheet_id = os.getenv("SHEET_ID")
              sheet_name = os.getenv("SHEET_NAME")
              creds_json = os.getenv("GOOGLE_SERVICE_ACCOUNT_JSON")
              shop_store_raw = os.getenv("SHOPIFY_STORE")
              shop_store = normalize_store(shop_store_raw)
              shop_token = os.getenv("SHOPIFY_ACCESS_TOKEN")
              shop_version = os.getenv("SHOPIFY_API_VERSION", "2025-01")
              if not creds_json or not sheet_id:
                  print("Missing GOOGLE_SERVICE_ACCOUNT_JSON or SHEET_ID")
                  return
              provider_map = load_provider_map(provider_url, ref_col, dist_col)
              ws = open_worksheet(creds_json, sheet_id, sheet_name)
              if shop_store and shop_token:
                  sres = update_prices_in_shopify(ws, provider_map, sku_col, shop_store, shop_token, shop_version)
                  smp = sres.get("samples", {})
                  print(f"shopify_updated={sres['updated']} shopify_skipped_compare={sres['skipped_compare']} shopify_missing_dist={sres['missing_dist']} shopify_not_found={sres['not_found']} shopify_unchanged={sres['unchanged']}")
                  print(f"samples_matched={smp.get('matched', [])}")
                  print(f"samples_updated={smp.get('updated', [])}")
                  print(f"samples_skipped_compare={smp.get('skipped_compare', [])}")
                  print(f"samples_missing_dist={smp.get('missing_dist', [])}")
                  print(f"samples_not_found={smp.get('not_found', [])}")
                  print(f"samples_unchanged={smp.get('unchanged', [])}")
              else:
                  print("Missing SHOPIFY_STORE or SHOPIFY_ACCESS_TOKEN")

          if __name__ == "__main__":
              main()
          PY

      - name: Install dependencies
        run: pip install gspread==6.1.4 google-auth==2.35.0 requests==2.32.3

      - name: Run updater
        env:
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          SHEET_ID: ${{ secrets.SHEET_ID }}
          SHEET_NAME: ${{ secrets.SHEET_NAME }}
          PROVIDER_URL: ${{ secrets.PROVIDER_URL }}
          SHOPIFY_STORE: ${{ secrets.SHOPIFY_STORE }}
          SHOPIFY_ACCESS_TOKEN: ${{ secrets.SHOPIFY_ACCESS_TOKEN }}
          SHOPIFY_API_VERSION: 2025-01
          SKU_COLUMN: SKU
          PROVIDER_REFERENCE_COLUMN: referencia
          PROVIDER_DISTRIBUTOR_PRICE_COLUMN: precio_distribuidores
          ROUNDING_MULTIPLE: 5
          ROUNDING_STRATEGY: ceil
          ROUNDING_AVOID_HUNDREDS: true
          SHOPIFY_THROTTLE_SECONDS: 3
          SKU_PREFIX_TO_STRIP: D-
        run: python app.py
